% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/apply_tudor_locke.R
\name{apply_tudor_locke}
\alias{apply_tudor_locke}
\title{Apply the Tudor-Locke algorithm}
\usage{
apply_tudor_locke(
  agdb,
  n_bedtime_start = 5,
  n_wake_time_end = 10,
  min_sleep_period = 160,
  max_sleep_period = 1440,
  min_nonzero_epochs = 0
)
}
\arguments{
\item{agdb}{A \code{tibble} of activity data with an \code{epochlength} attribute.
The epoch length must be 60 seconds.
Each epoch should be scored as asleep (S) or awake (W), using the Sadeh,
the Cole-Kripke or a custom algorithm.}

\item{n_bedtime_start}{Bedtime definition, in minutes. The default is 5.}

\item{n_wake_time_end}{Wake time definition, in minutes. The default is 10.}

\item{min_sleep_period}{Minimum sleep period length, in minutes.
The default is 160.}

\item{max_sleep_period}{Maximum sleep period length, in minutes.
The default is 1440 (24 hours).}

\item{min_nonzero_epochs}{Minimum number of epochs with non-zero
activity. The default is 0.}
}
\value{
A summary \code{tibble} of the detected sleep periods.
If the activity data is grouped, then sleep periods are detected
separately for each group.
\describe{
\item{in_bed_time}{The first minute of the bedtime.}
\item{out_bed_time}{The first minute of wake time.}
\item{onset}{The first minute that the algorithm scores "asleep".}
\item{latency}{The time elapsed between bedtime and sleep onset.
By the definition of Tudor-Locke, latency is 0.}
\item{efficiency}{The number of sleep minutes divided
by the bedtime minutes.}
\item{duration}{The duration of the sleep period, in minutes.}
\item{activity_counts}{The sum of activity counts for the entire
sleep period.}
\item{total_sleep_time}{The number of minutes scored as "asleep"
during the sleep period.}
\item{wake_after_onset}{The number of minutes scored as "awake",
minus the sleep latency, during the sleep period.}
\item{nb_awakenings}{The number of awakening episodes.}
\item{ave_awakening}{The average length, in minutes, of all
awakening episodes.}
\item{movement_index}{Proportion of awake time out of the total
time in bed, in percentages.}
\item{fragmentation_index}{Proportion of one-minute sleep bouts
out of the number of sleep bouts of any length, in percentages.}
\item{sleep_fragmentation_index}{The sum of the movement and
fragmentation indices.}
\item{nonzero_epochs}{The number of epochs with activity > 0
(nonzero epochs).}
}
}
\description{
The Tudor-Locke algorithm detects periods of time in bed and, for
each period, computes sleep quality metrics such as total minutes in
bed, total sleep time, number and average length of awakenings,
movement and fragmentation index.
}
\details{
Once each one-minute epoch is labeled as asleep (S) or awake (W),
we can use the Tudor-Locke algorithm to detect periods of
\emph{bedtime} and \emph{sleep time}. By definition, \emph{sleep time} <
\emph{bedtime} since one can be in bed and not sleeping.

Bedtime is (the first minute of) \code{n_bedtime_start} consecutive
epochs/minutes labeled asleep (S). Similarly, wake time is
(the first minute of) of \code{n_wake_time_end} consecutive
epochs/minutes labeled awake (W), after a period of sleep.
The block of time between bedtime and wake time is one sleep
period, if the time elapsed is at least \code{min_sleep_period}
minutes. There can be multiple sleep periods in 24 hours but a
sleep period cannot be longer than \code{max_sleep_period} minutes.

For each sleep period, the algorithm calculates several measures of
sleep quality such as time asleep and time awake, number and average
length of awakenings, and movement and fragmentation indices.

This implementation of the Tudor-Locke algorithm detects all the sleep
periods that ActiLife detects and, in some cases, it detects
\emph{additional} sleep periods. There are (at least) two such cases:
\enumerate{
\item ActiLife filters out some sleep periods with \emph{exactly}
\code{min_nonzero_epochs} nonzero epochs. Alternatively, ActiLife
computes the number of nonzero epochs in a sleep period differently
and sometimes underestimates \code{nonzero_epochs} compared to
\code{\link[=apply_tudor_locke]{apply_tudor_locke()}}.
\item ActiLife filters out sleep periods that end when the activity
data ends, i.e., when the \code{out_bed_time} is also the final
timestamp in the \code{agdb} table.
}
}
\examples{
library("dplyr")
library("lubridate")
data("gtxplus1day")

# Detect sleep periods using Sadeh as the sleep/awake algorithm
# and Tudor-Locke as the sleep period algorithm
agdb <- gtxplus1day \%>\%
  collapse_epochs(60) \%>\%
  filter(day(timestamp) == 28)
periods_sleep <- agdb \%>\%
  apply_sadeh() \%>\%
  apply_tudor_locke(min_sleep_period = 60)
periods_sleep

# Group and summarize by an extra varible (hour < 6 or not), which
# splits one long sleep period in two
agdb <- agdb \%>\%
  mutate(hour_lt6 = hour(timestamp) < 6) \%>\%
  group_by(hour_lt6)
periods_sleep <- agdb \%>\%
  apply_sadeh() \%>\%
  apply_tudor_locke(min_sleep_period = 60)
periods_sleep
}
\references{
C Tudor-Locke, TV Barreira, JM Schuna Jr, EF Mire and
PT Katzmarzyk. Fully automated waist-worn accelerometer algorithm
for detecting children's sleep-period time separate from 24-h
physical activity or sedentary behaviors. \emph{Applied Physiology},
Nutrition, and Metabolism, 39(1):53â€“57, 2014.

ActiLife 6 User's Manual by the ActiGraph Software
Department. 04/03/2012.
}
\seealso{
\code{\link[=apply_sadeh]{apply_sadeh()}}, \code{\link[=apply_cole_kripke]{apply_cole_kripke()}}
}
